<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Viewer</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #2c2c2c; font-family: sans-serif; }
        
        #drop-area {
            position: absolute; width: 100%; height: 100%;
            display: flex; justify-content: center; align-items: center;
            background-color: rgba(0, 0, 0, 0.5); color: white;
            font-size: 1.2em; text-align: center; z-index: 10;
            border: 4px dashed #fff; box-sizing: border-box; cursor: pointer; padding: 20px;
        }
        
        /* メニュー開閉ボタン：右上に配置 */
        #toggle-menu {
            position: fixed; top: 20px; right: 20px;
            z-index: 40; background: #444; color: white;
            border: 1px solid white; border-radius: 8px;
            width: 70px; height: 40px; cursor: pointer;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
            font-size: 12px; font-weight: bold;
        }

        /* コントロールパネル：下から展開し、MENUボタンと重ならないように調整 */
        #control-panel {
            position: fixed; bottom: 0; left: 0; width: 100%;
            background-color: rgba(0, 0, 0, 0.9); padding: 20px 10px;
            color: white; display: flex; flex-wrap: wrap;
            justify-content: center; gap: 8px; z-index: 30;
            max-height: 60vh; overflow-y: auto; box-sizing: border-box;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border-top-left-radius: 20px; border-top-right-radius: 20px;
            box-shadow: 0 -5px 15px rgba(0,0,0,0.5);
        }
        
        #control-panel.collapsed {
            transform: translateY(100%);
        }

        .control-group {
            display: flex; flex-direction: column; background: #333;
            padding: 8px; border-radius: 8px; font-size: 11px; min-width: 100px;
            flex: 1 1 100px; max-width: 150px;
        }
        
        .control-row { display: flex; align-items: center; justify-content: space-between; gap: 4px; }
        
        button {
            background-color: #555; color: white; border: 1px solid #fff;
            padding: 10px; cursor: pointer; border-radius: 6px; font-size: 12px;
            min-width: 80px;
        }
        
        button:active { background-color: #888; }
        label { margin-bottom: 4px; color: #ddd; font-weight: bold; }
        input[type="range"] { width: 100%; cursor: pointer; margin: 5px 0; }
        input[type="color"] { width: 40px; height: 40px; border: none; padding: 0; cursor: pointer; border-radius: 4px; }
        #file-input { display: none; }

        /* スマホ向け微調整 */
        @media (max-width: 600px) {
            .control-group { min-width: 140px; }
        }
    </style>
</head>
<body>
    <div id="drop-area">モデルを読み込む (Tap/Click/Drop)</div>
    <input type="file" id="file-input" accept=".glb,.gltf,.ply,.fbx,.obj,model/gltf-binary,model/gltf+json,model/obj,model/fbx">

    <button id="toggle-menu">MENU</button>

    <div id="control-panel">
        <button id="swap-axes">XYZ軸入替</button>
        <button id="save-model">保存</button>
        <button id="reset-rotation">回転リセット</button>
        <button id="reset-view">全クリア</button>
        
        <div class="control-group">
            <label>点サイズ</label>
            <input type="range" id="point-size" min="0.0001" max="0.02" step="0.0005" value="0.001">
        </div>

        <div class="control-group">
            <label>環境全体(影消し)</label>
            <input type="range" id="ambient-intensity" min="0" max="10" step="0.1" value="2.0">
        </div>

        <div class="control-group">
            <label>直射光(メイン)</label>
            <input type="range" id="direct-intensity" min="0" max="10" step="0.1" value="3.0">
        </div>

        <div class="control-group">
            <label>光源位置 X / Y / Z</label>
            <div class="control-row">
                <input type="range" id="light-x" min="-30" max="30" step="0.5" value="10">
                <input type="range" id="light-y" min="-30" max="30" step="0.5" value="10">
                <input type="range" id="light-z" min="-30" max="30" step="0.5" value="10">
            </div>
        </div>

        <div class="control-group" style="max-width: 60px; justify-content: center; align-items: center;">
            <label>背景</label>
            <input type="color" id="background-color" value="#2c2c2c">
        </div>
    </div>

    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
        "three/examples/jsm/controls/OrbitControls.js": "https://unpkg.com/three@0.159.0/examples/jsm/controls/OrbitControls.js",
        "three/examples/jsm/loaders/PLYLoader.js": "https://unpkg.com/three@0.159.0/examples/jsm/loaders/PLYLoader.js",
        "three/examples/jsm/loaders/GLTFLoader.js": "https://unpkg.com/three@0.159.0/examples/jsm/loaders/GLTFLoader.js",
        "three/examples/jsm/loaders/FBXLoader.js": "https://unpkg.com/three@0.159.0/examples/jsm/loaders/FBXLoader.js",
        "three/examples/jsm/loaders/OBJLoader.js": "https://unpkg.com/three@0.159.0/examples/jsm/loaders/OBJLoader.js",
        "three/examples/jsm/exporters/PLYExporter.js": "https://unpkg.com/three@0.159.0/examples/jsm/exporters/PLYExporter.js",
        "three/examples/jsm/exporters/GLTFExporter.js": "https://unpkg.com/three@0.159.0/examples/jsm/exporters/GLTFExporter.js"
      }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
        import { PLYLoader } from 'three/examples/jsm/loaders/PLYLoader.js';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
        import { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader.js';
        import { OBJLoader } from 'three/examples/jsm/loaders/OBJLoader.js';
        import { PLYExporter } from 'three/examples/jsm/exporters/PLYExporter.js';
        import { GLTFExporter } from 'three/examples/jsm/exporters/GLTFExporter.js';

        let scene, camera, renderer, controls, loadedModel = null, originalFileType = '';
        let hemiLight, directionalLight, backLight;
        let swapCount = 0;

        const dropArea = document.getElementById('drop-area');
        const fileInput = document.getElementById('file-input');
        const toggleMenu = document.getElementById('toggle-menu');
        const controlPanel = document.getElementById('control-panel');

        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update();
            if (renderer && scene && camera) renderer.render(scene, camera);
        }

        function onModelLoaded(model) {
            loadedModel = model;
            scene.add(loadedModel);
            loadedModel.traverse((child) => {
                if (child.isMesh && child.material) {
                    const materials = Array.isArray(child.material) ? child.material : [child.material];
                    materials.forEach(m => {
                        if (m.color && m.color.r === 0 && m.color.g === 0 && m.color.b === 0) m.color.set(0xcccccc);
                        if (m instanceof THREE.MeshStandardMaterial) {
                            m.metalness = 0.2; m.roughness = 0.8; m.envMapIntensity = 1.5;
                        }
                        m.needsUpdate = true;
                    });
                }
            });
            fitCameraToObject(loadedModel);
        }

        function handleFile(file) {
            if (!file) return;
            const ext = file.name.split('.').pop().toLowerCase();
            originalFileType = ext;
            const url = URL.createObjectURL(file);
            if (loadedModel) scene.remove(loadedModel);
            
            if (ext === 'ply') {
                new PLYLoader().load(url, (geo) => {
                    const mat = new THREE.PointsMaterial({ size: parseFloat(document.getElementById('point-size').value), vertexColors: geo.attributes.color !== undefined });
                    onModelLoaded(new THREE.Points(geo, mat));
                });
            } else if (ext === 'gltf' || ext === 'glb') {
                new GLTFLoader().load(url, (gltf) => onModelLoaded(gltf.scene));
            } else if (ext === 'fbx') {
                new FBXLoader().load(url, (obj) => onModelLoaded(obj));
            } else if (ext === 'obj') {
                new OBJLoader().load(url, (obj) => onModelLoaded(obj));
            }
            dropArea.style.display = 'none';
        }

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 20000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.setClearColor(0x2c2c2c, 1);
            document.body.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.mouseButtons = {
                LEFT: THREE.MOUSE.ROTATE,
                MIDDLE: THREE.MOUSE.DOLLY,
                RIGHT: THREE.MOUSE.PAN
            };
            controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault());

            hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 2.0);
            scene.add(hemiLight);
            directionalLight = new THREE.DirectionalLight(0xffffff, 3.0);
            directionalLight.position.set(10, 10, 10);
            scene.add(directionalLight);
            backLight = new THREE.DirectionalLight(0xffffff, 1.5);
            backLight.position.set(-10, -5, -10);
            scene.add(backLight);

            // UIコントロール
            toggleMenu.onclick = () => {
                controlPanel.classList.toggle('collapsed');
                toggleMenu.innerText = controlPanel.classList.contains('collapsed') ? 'MENU' : 'CLOSE';
            };
            
            // 初回読み込み時はメニューを閉じておく（任意）
            controlPanel.classList.add('collapsed');

            dropArea.onclick = () => fileInput.click();
            fileInput.onchange = (e) => handleFile(e.target.files[0]);
            window.addEventListener('dragover', (e) => e.preventDefault());
            window.addEventListener('drop', (e) => { e.preventDefault(); handleFile(e.dataTransfer.files[0]); });

            document.getElementById('swap-axes').onclick = () => {
                if (!loadedModel) return;
                swapCount++;
                const matrix = new THREE.Matrix4();
                const rot = [[0,1,0,0, 1,0,0,0, 0,0,1,0, 0,0,0,1],[1,0,0,0, 0,0,1,0, 0,1,0,0, 0,0,0,1],[0,0,1,0, 0,1,0,0, 1,0,0,0, 0,0,0,1]];
                matrix.set(...rot[swapCount % 3]);
                loadedModel.applyMatrix4(matrix);
                fitCameraToObject(loadedModel);
            };
            document.getElementById('save-model').onclick = () => {
                if (!loadedModel) return;
                const exporter = (originalFileType === 'ply') ? new PLYExporter() : new GLTFExporter();
                exporter.parse(loadedModel, (res) => {
                    const blob = new Blob([res instanceof ArrayBuffer ? res : JSON.stringify(res)], {type:'application/octet-stream'});
                    const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `model.${originalFileType}`; a.click();
                }, { binary: true });
            };
            document.getElementById('reset-rotation').onclick = () => { if(loadedModel){ loadedModel.rotation.set(0,0,0); loadedModel.position.set(0,0,0); fitCameraToObject(loadedModel); } };
            document.getElementById('reset-view').onclick = () => location.reload();

            document.getElementById('point-size').oninput = (e) => { if(loadedModel) loadedModel.traverse(c => { if(c.isPoints) c.material.size = parseFloat(e.target.value); }); };
            document.getElementById('ambient-intensity').oninput = (e) => hemiLight.intensity = parseFloat(e.target.value);
            document.getElementById('direct-intensity').oninput = (e) => { 
                const v = parseFloat(e.target.value); directionalLight.intensity = v; backLight.intensity = v * 0.5;
            };
            document.getElementById('background-color').oninput = (e) => renderer.setClearColor(e.target.value);
            const updateLightPos = () => {
                const x = parseFloat(document.getElementById('light-x').value), y = parseFloat(document.getElementById('light-y').value), z = parseFloat(document.getElementById('light-z').value);
                directionalLight.position.set(x, y, z); backLight.position.set(-x, -y * 0.5, -z);
            };
            document.getElementById('light-x').oninput = updateLightPos;
            document.getElementById('light-y').oninput = updateLightPos;
            document.getElementById('light-z').oninput = updateLightPos;

            window.addEventListener('resize', () => { camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
            animate();
        }

        function fitCameraToObject(object) {
            const box = new THREE.Box3().setFromObject(object);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const cameraZ = Math.abs(maxDim / 2 / Math.tan(camera.fov * Math.PI / 360));
            camera.position.set(center.x, center.y, center.z + cameraZ * 3.0);
            controls.target.copy(center);
            controls.update();
        }

        init();
    </script>
</body>
</html>